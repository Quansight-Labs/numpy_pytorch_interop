# this file is autogenerated via gen_ufuncs.py
# do not edit manually!

import torch

import _util



def absolute(x, /, out=None, *, where=True, casting='same_kind', order='K',
          dtype=None, subok=False, **kwds):
    _util.subok_not_ok(subok=subok)
    if order != 'K' or casting != 'same_kind' or not where:
        raise NotImplementedError
    if out is not None:
      # XXX dtypes, casting
        out = out.to(dtype)
    result = torch.absolute(torch.as_tensor(x), out=out)
    if dtype is not None:
        result = result.to(dtype)
    
    return result



def absolute(x, /, out=None, *, where=True, casting='same_kind', order='K',
          dtype=None, subok=False, **kwds):
    _util.subok_not_ok(subok=subok)
    if order != 'K' or casting != 'same_kind' or not where:
        raise NotImplementedError
    if out is not None:
      # XXX dtypes, casting
        out = out.to(dtype)
    result = torch.absolute(torch.as_tensor(x), out=out)
    if dtype is not None:
        result = result.to(dtype)
    
    return result



def arccos(x, /, out=None, *, where=True, casting='same_kind', order='K',
          dtype=None, subok=False, **kwds):
    _util.subok_not_ok(subok=subok)
    if order != 'K' or casting != 'same_kind' or not where:
        raise NotImplementedError
    if out is not None:
      # XXX dtypes, casting
        out = out.to(dtype)
    result = torch.arccos(torch.as_tensor(x), out=out)
    if dtype is not None:
        result = result.to(dtype)
    
    return result



def arccosh(x, /, out=None, *, where=True, casting='same_kind', order='K',
          dtype=None, subok=False, **kwds):
    _util.subok_not_ok(subok=subok)
    if order != 'K' or casting != 'same_kind' or not where:
        raise NotImplementedError
    if out is not None:
      # XXX dtypes, casting
        out = out.to(dtype)
    result = torch.arccosh(torch.as_tensor(x), out=out)
    if dtype is not None:
        result = result.to(dtype)
    
    return result



def arcsin(x, /, out=None, *, where=True, casting='same_kind', order='K',
          dtype=None, subok=False, **kwds):
    _util.subok_not_ok(subok=subok)
    if order != 'K' or casting != 'same_kind' or not where:
        raise NotImplementedError
    if out is not None:
      # XXX dtypes, casting
        out = out.to(dtype)
    result = torch.arcsin(torch.as_tensor(x), out=out)
    if dtype is not None:
        result = result.to(dtype)
    
    return result



def arcsinh(x, /, out=None, *, where=True, casting='same_kind', order='K',
          dtype=None, subok=False, **kwds):
    _util.subok_not_ok(subok=subok)
    if order != 'K' or casting != 'same_kind' or not where:
        raise NotImplementedError
    if out is not None:
      # XXX dtypes, casting
        out = out.to(dtype)
    result = torch.arcsinh(torch.as_tensor(x), out=out)
    if dtype is not None:
        result = result.to(dtype)
    
    return result



def arctan(x, /, out=None, *, where=True, casting='same_kind', order='K',
          dtype=None, subok=False, **kwds):
    _util.subok_not_ok(subok=subok)
    if order != 'K' or casting != 'same_kind' or not where:
        raise NotImplementedError
    if out is not None:
      # XXX dtypes, casting
        out = out.to(dtype)
    result = torch.arctan(torch.as_tensor(x), out=out)
    if dtype is not None:
        result = result.to(dtype)
    
    return result



def arctanh(x, /, out=None, *, where=True, casting='same_kind', order='K',
          dtype=None, subok=False, **kwds):
    _util.subok_not_ok(subok=subok)
    if order != 'K' or casting != 'same_kind' or not where:
        raise NotImplementedError
    if out is not None:
      # XXX dtypes, casting
        out = out.to(dtype)
    result = torch.arctanh(torch.as_tensor(x), out=out)
    if dtype is not None:
        result = result.to(dtype)
    
    return result



def cbrt(x, /, out=None, *, where=True, casting='same_kind', order='K',
          dtype=None, subok=False, **kwds):
    _util.subok_not_ok(subok=subok)
    if order != 'K' or casting != 'same_kind' or not where:
        raise NotImplementedError
    if out is not None:
      # XXX dtypes, casting
        out = out.to(dtype)
    result = torch.pow(torch.as_tensor(x), 1/3, out=out)
    if dtype is not None:
        result = result.to(dtype)
    
    return result



def ceil(x, /, out=None, *, where=True, casting='same_kind', order='K',
          dtype=None, subok=False, **kwds):
    _util.subok_not_ok(subok=subok)
    if order != 'K' or casting != 'same_kind' or not where:
        raise NotImplementedError
    if out is not None:
      # XXX dtypes, casting
        out = out.to(dtype)
    result = torch.ceil(torch.as_tensor(x), out=out)
    if dtype is not None:
        result = result.to(dtype)
    
    return result



def conjugate(x, /, out=None, *, where=True, casting='same_kind', order='K',
          dtype=None, subok=False, **kwds):
    _util.subok_not_ok(subok=subok)
    if order != 'K' or casting != 'same_kind' or not where:
        raise NotImplementedError
    if out is not None:
      # XXX dtypes, casting
        out = out.to(dtype)
    result = torch.conj_physical(torch.as_tensor(x), out=out)
    if dtype is not None:
        result = result.to(dtype)
    
    return result



def conjugate(x, /, out=None, *, where=True, casting='same_kind', order='K',
          dtype=None, subok=False, **kwds):
    _util.subok_not_ok(subok=subok)
    if order != 'K' or casting != 'same_kind' or not where:
        raise NotImplementedError
    if out is not None:
      # XXX dtypes, casting
        out = out.to(dtype)
    result = torch.conj_physical(torch.as_tensor(x), out=out)
    if dtype is not None:
        result = result.to(dtype)
    
    return result



def cos(x, /, out=None, *, where=True, casting='same_kind', order='K',
          dtype=None, subok=False, **kwds):
    _util.subok_not_ok(subok=subok)
    if order != 'K' or casting != 'same_kind' or not where:
        raise NotImplementedError
    if out is not None:
      # XXX dtypes, casting
        out = out.to(dtype)
    result = torch.cos(torch.as_tensor(x), out=out)
    if dtype is not None:
        result = result.to(dtype)
    
    return result



def cosh(x, /, out=None, *, where=True, casting='same_kind', order='K',
          dtype=None, subok=False, **kwds):
    _util.subok_not_ok(subok=subok)
    if order != 'K' or casting != 'same_kind' or not where:
        raise NotImplementedError
    if out is not None:
      # XXX dtypes, casting
        out = out.to(dtype)
    result = torch.cosh(torch.as_tensor(x), out=out)
    if dtype is not None:
        result = result.to(dtype)
    
    return result



def deg2rad(x, /, out=None, *, where=True, casting='same_kind', order='K',
          dtype=None, subok=False, **kwds):
    _util.subok_not_ok(subok=subok)
    if order != 'K' or casting != 'same_kind' or not where:
        raise NotImplementedError
    if out is not None:
      # XXX dtypes, casting
        out = out.to(dtype)
    result = torch.deg2rad(torch.as_tensor(x), out=out)
    if dtype is not None:
        result = result.to(dtype)
    
    return result



def degrees(x, /, out=None, *, where=True, casting='same_kind', order='K',
          dtype=None, subok=False, **kwds):
    _util.subok_not_ok(subok=subok)
    if order != 'K' or casting != 'same_kind' or not where:
        raise NotImplementedError
    if out is not None:
      # XXX dtypes, casting
        out = out.to(dtype)
    result = torch.rad2deg(torch.as_tensor(x), out=out)
    if dtype is not None:
        result = result.to(dtype)
    
    return result



def exp(x, /, out=None, *, where=True, casting='same_kind', order='K',
          dtype=None, subok=False, **kwds):
    _util.subok_not_ok(subok=subok)
    if order != 'K' or casting != 'same_kind' or not where:
        raise NotImplementedError
    if out is not None:
      # XXX dtypes, casting
        out = out.to(dtype)
    result = torch.exp(torch.as_tensor(x), out=out)
    if dtype is not None:
        result = result.to(dtype)
    
    return result



def exp2(x, /, out=None, *, where=True, casting='same_kind', order='K',
          dtype=None, subok=False, **kwds):
    _util.subok_not_ok(subok=subok)
    if order != 'K' or casting != 'same_kind' or not where:
        raise NotImplementedError
    if out is not None:
      # XXX dtypes, casting
        out = out.to(dtype)
    result = torch.exp2(torch.as_tensor(x), out=out)
    if dtype is not None:
        result = result.to(dtype)
    
    return result



def expm1(x, /, out=None, *, where=True, casting='same_kind', order='K',
          dtype=None, subok=False, **kwds):
    _util.subok_not_ok(subok=subok)
    if order != 'K' or casting != 'same_kind' or not where:
        raise NotImplementedError
    if out is not None:
      # XXX dtypes, casting
        out = out.to(dtype)
    result = torch.expm1(torch.as_tensor(x), out=out)
    if dtype is not None:
        result = result.to(dtype)
    
    return result



def fabs(x, /, out=None, *, where=True, casting='same_kind', order='K',
          dtype=None, subok=False, **kwds):
    _util.subok_not_ok(subok=subok)
    if order != 'K' or casting != 'same_kind' or not where:
        raise NotImplementedError
    if out is not None:
      # XXX dtypes, casting
        out = out.to(dtype)
    result = torch.absolute(torch.as_tensor(x), out=out)
    if dtype is not None:
        result = result.to(dtype)
    
    return result



def floor(x, /, out=None, *, where=True, casting='same_kind', order='K',
          dtype=None, subok=False, **kwds):
    _util.subok_not_ok(subok=subok)
    if order != 'K' or casting != 'same_kind' or not where:
        raise NotImplementedError
    if out is not None:
      # XXX dtypes, casting
        out = out.to(dtype)
    result = torch.floor(torch.as_tensor(x), out=out)
    if dtype is not None:
        result = result.to(dtype)
    
    return result



def isfinite(x, /, out=None, *, where=True, casting='same_kind', order='K',
          dtype=None, subok=False, **kwds):
    _util.subok_not_ok(subok=subok)
    if order != 'K' or casting != 'same_kind' or not where:
        raise NotImplementedError
    if out is not None:
      # XXX dtypes, casting
        out = out.to(dtype)
    result = torch.isfinite(torch.as_tensor(x))
    if dtype is not None:
        result = result.to(dtype)
    
    if out is not None:
        out[...] = result

    return result



def isinf(x, /, out=None, *, where=True, casting='same_kind', order='K',
          dtype=None, subok=False, **kwds):
    _util.subok_not_ok(subok=subok)
    if order != 'K' or casting != 'same_kind' or not where:
        raise NotImplementedError
    if out is not None:
      # XXX dtypes, casting
        out = out.to(dtype)
    result = torch.isinf(torch.as_tensor(x))
    if dtype is not None:
        result = result.to(dtype)
    
    if out is not None:
        out[...] = result

    return result



def isnan(x, /, out=None, *, where=True, casting='same_kind', order='K',
          dtype=None, subok=False, **kwds):
    _util.subok_not_ok(subok=subok)
    if order != 'K' or casting != 'same_kind' or not where:
        raise NotImplementedError
    if out is not None:
      # XXX dtypes, casting
        out = out.to(dtype)
    result = torch.isnan(torch.as_tensor(x))
    if dtype is not None:
        result = result.to(dtype)
    
    if out is not None:
        out[...] = result

    return result



def log(x, /, out=None, *, where=True, casting='same_kind', order='K',
          dtype=None, subok=False, **kwds):
    _util.subok_not_ok(subok=subok)
    if order != 'K' or casting != 'same_kind' or not where:
        raise NotImplementedError
    if out is not None:
      # XXX dtypes, casting
        out = out.to(dtype)
    result = torch.log(torch.as_tensor(x), out=out)
    if dtype is not None:
        result = result.to(dtype)
    
    return result



def log10(x, /, out=None, *, where=True, casting='same_kind', order='K',
          dtype=None, subok=False, **kwds):
    _util.subok_not_ok(subok=subok)
    if order != 'K' or casting != 'same_kind' or not where:
        raise NotImplementedError
    if out is not None:
      # XXX dtypes, casting
        out = out.to(dtype)
    result = torch.log10(torch.as_tensor(x), out=out)
    if dtype is not None:
        result = result.to(dtype)
    
    return result



def log1p(x, /, out=None, *, where=True, casting='same_kind', order='K',
          dtype=None, subok=False, **kwds):
    _util.subok_not_ok(subok=subok)
    if order != 'K' or casting != 'same_kind' or not where:
        raise NotImplementedError
    if out is not None:
      # XXX dtypes, casting
        out = out.to(dtype)
    result = torch.log1p(torch.as_tensor(x), out=out)
    if dtype is not None:
        result = result.to(dtype)
    
    return result



def log2(x, /, out=None, *, where=True, casting='same_kind', order='K',
          dtype=None, subok=False, **kwds):
    _util.subok_not_ok(subok=subok)
    if order != 'K' or casting != 'same_kind' or not where:
        raise NotImplementedError
    if out is not None:
      # XXX dtypes, casting
        out = out.to(dtype)
    result = torch.log2(torch.as_tensor(x), out=out)
    if dtype is not None:
        result = result.to(dtype)
    
    return result



def logical_not(x, /, out=None, *, where=True, casting='same_kind', order='K',
          dtype=None, subok=False, **kwds):
    _util.subok_not_ok(subok=subok)
    if order != 'K' or casting != 'same_kind' or not where:
        raise NotImplementedError
    if out is not None:
      # XXX dtypes, casting
        out = out.to(dtype)
    result = torch.logical_not(torch.as_tensor(x), out=out)
    if dtype is not None:
        result = result.to(dtype)
    
    return result



def negative(x, /, out=None, *, where=True, casting='same_kind', order='K',
          dtype=None, subok=False, **kwds):
    _util.subok_not_ok(subok=subok)
    if order != 'K' or casting != 'same_kind' or not where:
        raise NotImplementedError
    if out is not None:
      # XXX dtypes, casting
        out = out.to(dtype)
    result = torch.negative(torch.as_tensor(x), out=out)
    if dtype is not None:
        result = result.to(dtype)
    
    return result



def positive(x, /, out=None, *, where=True, casting='same_kind', order='K',
          dtype=None, subok=False, **kwds):
    _util.subok_not_ok(subok=subok)
    if order != 'K' or casting != 'same_kind' or not where:
        raise NotImplementedError
    if out is not None:
      # XXX dtypes, casting
        out = out.to(dtype)
    result = +torch.as_tensor(x)
    if dtype is not None:
        result = result.to(dtype)
    
    if out is not None:
        out[...] = result

    return result



def rad2deg(x, /, out=None, *, where=True, casting='same_kind', order='K',
          dtype=None, subok=False, **kwds):
    _util.subok_not_ok(subok=subok)
    if order != 'K' or casting != 'same_kind' or not where:
        raise NotImplementedError
    if out is not None:
      # XXX dtypes, casting
        out = out.to(dtype)
    result = torch.rad2deg(torch.as_tensor(x), out=out)
    if dtype is not None:
        result = result.to(dtype)
    
    return result



def radians(x, /, out=None, *, where=True, casting='same_kind', order='K',
          dtype=None, subok=False, **kwds):
    _util.subok_not_ok(subok=subok)
    if order != 'K' or casting != 'same_kind' or not where:
        raise NotImplementedError
    if out is not None:
      # XXX dtypes, casting
        out = out.to(dtype)
    result = torch.deg2rad(torch.as_tensor(x), out=out)
    if dtype is not None:
        result = result.to(dtype)
    
    return result



def reciprocal(x, /, out=None, *, where=True, casting='same_kind', order='K',
          dtype=None, subok=False, **kwds):
    _util.subok_not_ok(subok=subok)
    if order != 'K' or casting != 'same_kind' or not where:
        raise NotImplementedError
    if out is not None:
      # XXX dtypes, casting
        out = out.to(dtype)
    result = torch.reciprocal(torch.as_tensor(x), out=out)
    if dtype is not None:
        result = result.to(dtype)
    
    return result



def rint(x, /, out=None, *, where=True, casting='same_kind', order='K',
          dtype=None, subok=False, **kwds):
    _util.subok_not_ok(subok=subok)
    if order != 'K' or casting != 'same_kind' or not where:
        raise NotImplementedError
    if out is not None:
      # XXX dtypes, casting
        out = out.to(dtype)
    result = torch.round(torch.as_tensor(x), out=out)
    if dtype is not None:
        result = result.to(dtype)
    
    return result



def sign(x, /, out=None, *, where=True, casting='same_kind', order='K',
          dtype=None, subok=False, **kwds):
    _util.subok_not_ok(subok=subok)
    if order != 'K' or casting != 'same_kind' or not where:
        raise NotImplementedError
    if out is not None:
      # XXX dtypes, casting
        out = out.to(dtype)
    result = torch.sign(torch.as_tensor(x), out=out)
    if dtype is not None:
        result = result.to(dtype)
    
    return result



def signbit(x, /, out=None, *, where=True, casting='same_kind', order='K',
          dtype=None, subok=False, **kwds):
    _util.subok_not_ok(subok=subok)
    if order != 'K' or casting != 'same_kind' or not where:
        raise NotImplementedError
    if out is not None:
      # XXX dtypes, casting
        out = out.to(dtype)
    result = torch.signbit(torch.as_tensor(x), out=out)
    if dtype is not None:
        result = result.to(dtype)
    
    return result



def sin(x, /, out=None, *, where=True, casting='same_kind', order='K',
          dtype=None, subok=False, **kwds):
    _util.subok_not_ok(subok=subok)
    if order != 'K' or casting != 'same_kind' or not where:
        raise NotImplementedError
    if out is not None:
      # XXX dtypes, casting
        out = out.to(dtype)
    result = torch.sin(torch.as_tensor(x), out=out)
    if dtype is not None:
        result = result.to(dtype)
    
    return result



def sinh(x, /, out=None, *, where=True, casting='same_kind', order='K',
          dtype=None, subok=False, **kwds):
    _util.subok_not_ok(subok=subok)
    if order != 'K' or casting != 'same_kind' or not where:
        raise NotImplementedError
    if out is not None:
      # XXX dtypes, casting
        out = out.to(dtype)
    result = torch.sinh(torch.as_tensor(x), out=out)
    if dtype is not None:
        result = result.to(dtype)
    
    return result



def sqrt(x, /, out=None, *, where=True, casting='same_kind', order='K',
          dtype=None, subok=False, **kwds):
    _util.subok_not_ok(subok=subok)
    if order != 'K' or casting != 'same_kind' or not where:
        raise NotImplementedError
    if out is not None:
      # XXX dtypes, casting
        out = out.to(dtype)
    result = torch.sqrt(torch.as_tensor(x), out=out)
    if dtype is not None:
        result = result.to(dtype)
    
    return result



def square(x, /, out=None, *, where=True, casting='same_kind', order='K',
          dtype=None, subok=False, **kwds):
    _util.subok_not_ok(subok=subok)
    if order != 'K' or casting != 'same_kind' or not where:
        raise NotImplementedError
    if out is not None:
      # XXX dtypes, casting
        out = out.to(dtype)
    result = torch.square(torch.as_tensor(x), out=out)
    if dtype is not None:
        result = result.to(dtype)
    
    return result



def tan(x, /, out=None, *, where=True, casting='same_kind', order='K',
          dtype=None, subok=False, **kwds):
    _util.subok_not_ok(subok=subok)
    if order != 'K' or casting != 'same_kind' or not where:
        raise NotImplementedError
    if out is not None:
      # XXX dtypes, casting
        out = out.to(dtype)
    result = torch.tan(torch.as_tensor(x), out=out)
    if dtype is not None:
        result = result.to(dtype)
    
    return result



def tanh(x, /, out=None, *, where=True, casting='same_kind', order='K',
          dtype=None, subok=False, **kwds):
    _util.subok_not_ok(subok=subok)
    if order != 'K' or casting != 'same_kind' or not where:
        raise NotImplementedError
    if out is not None:
      # XXX dtypes, casting
        out = out.to(dtype)
    result = torch.tanh(torch.as_tensor(x), out=out)
    if dtype is not None:
        result = result.to(dtype)
    
    return result



def trunc(x, /, out=None, *, where=True, casting='same_kind', order='K',
          dtype=None, subok=False, **kwds):
    _util.subok_not_ok(subok=subok)
    if order != 'K' or casting != 'same_kind' or not where:
        raise NotImplementedError
    if out is not None:
      # XXX dtypes, casting
        out = out.to(dtype)
    result = torch.trunc(torch.as_tensor(x), out=out)
    if dtype is not None:
        result = result.to(dtype)
    
    return result



__all__ = ['absolute', 'absolute', 'arccos', 'arccosh', 'arcsin', 'arcsinh', 'arctan', 'arctanh', 'cbrt', 'ceil', 'conjugate', 'conjugate', 'cos', 'cosh', 'deg2rad', 'degrees', 'exp', 'exp2', 'expm1', 'fabs', 'floor', 'isfinite', 'isinf', 'isnan', 'log', 'log10', 'log1p', 'log2', 'logical_not', 'negative', 'positive', 'rad2deg', 'radians', 'reciprocal', 'rint', 'sign', 'signbit', 'sin', 'sinh', 'sqrt', 'square', 'tan', 'tanh', 'trunc']