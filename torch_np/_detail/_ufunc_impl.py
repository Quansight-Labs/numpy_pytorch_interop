import torch

from . import _util


def deco_ufunc(torch_func):
    """Common infra for binary ufuncs: receive tensors, sort out type casting,
    broadcasting,  and delegate to the pytorch function for actual work.


    Converting array-likes into arrays, unwrapping them into tensors etc
    is the caller responsibility.
    """

    def wrapped(
        tensors,
        /,
        out_shape_dtype=None,
        *,
        where=True,
        casting="same_kind",
        order="K",
        dtype=None,
        subok=False,
        **kwds,
    ):
        _util.subok_not_ok(subok=subok)
        if order != "K" or not where:
            raise NotImplementedError

        # XXX: dtype=... parameter
        if dtype is not None:
            raise NotImplementedError

        tensors = _util.cast_and_broadcast(tensors, out_shape_dtype, casting)

        result = torch_func(*tensors)
        return result

    return wrapped


# binary ufuncs: the list is autogenerated, cf autogen/gen_ufunc_2.py
# And edited manually! np.equal  <--> torch.eq, not torch.equal
add = deco_ufunc(torch.add)
arctan2 = deco_ufunc(torch.arctan2)
bitwise_and = deco_ufunc(torch.bitwise_and)
bitwise_or = deco_ufunc(torch.bitwise_or)
bitwise_xor = deco_ufunc(torch.bitwise_xor)
copysign = deco_ufunc(torch.copysign)
divide = deco_ufunc(torch.divide)
equal = deco_ufunc(torch.eq)
float_power = deco_ufunc(torch.float_power)
floor_divide = deco_ufunc(torch.floor_divide)
fmax = deco_ufunc(torch.fmax)
fmin = deco_ufunc(torch.fmin)
fmod = deco_ufunc(torch.fmod)
gcd = deco_ufunc(torch.gcd)
greater = deco_ufunc(torch.greater)
greater_equal = deco_ufunc(torch.greater_equal)
heaviside = deco_ufunc(torch.heaviside)
hypot = deco_ufunc(torch.hypot)
lcm = deco_ufunc(torch.lcm)
ldexp = deco_ufunc(torch.ldexp)
left_shift = deco_ufunc(torch.bitwise_left_shift)
less = deco_ufunc(torch.less)
less_equal = deco_ufunc(torch.less_equal)
logaddexp = deco_ufunc(torch.logaddexp)
logaddexp2 = deco_ufunc(torch.logaddexp2)
logical_and = deco_ufunc(torch.logical_and)
logical_or = deco_ufunc(torch.logical_or)
logical_xor = deco_ufunc(torch.logical_xor)
matmul = deco_ufunc(torch.matmul)
maximum = deco_ufunc(torch.maximum)
minimum = deco_ufunc(torch.minimum)
remainder = deco_ufunc(torch.remainder)
multiply = deco_ufunc(torch.multiply)
nextafter = deco_ufunc(torch.nextafter)
not_equal = deco_ufunc(torch.not_equal)
power = deco_ufunc(torch.pow)
remainder = deco_ufunc(torch.remainder)
right_shift = deco_ufunc(torch.bitwise_right_shift)
subtract = deco_ufunc(torch.subtract)
divide = deco_ufunc(torch.divide)


# unary ufuncs: the list is autogenerated, cf autogen/gen_ufunc_2.py
arccos = deco_ufunc(torch.arccos)
arccosh = deco_ufunc(torch.arccosh)
arcsin = deco_ufunc(torch.arcsin)
arcsinh = deco_ufunc(torch.arcsinh)
arctan = deco_ufunc(torch.arctan)
arctanh = deco_ufunc(torch.arctanh)
ceil = deco_ufunc(torch.ceil)
conjugate = deco_ufunc(torch.conj_physical)
# conjugate = deco_ufunc(torch.conj_physical)
cos = deco_ufunc(torch.cos)
cosh = deco_ufunc(torch.cosh)
deg2rad = deco_ufunc(torch.deg2rad)
degrees = deco_ufunc(torch.rad2deg)
exp = deco_ufunc(torch.exp)
exp2 = deco_ufunc(torch.exp2)
expm1 = deco_ufunc(torch.expm1)
fabs = deco_ufunc(torch.absolute)
floor = deco_ufunc(torch.floor)
isfinite = deco_ufunc(torch.isfinite)
isinf = deco_ufunc(torch.isinf)
isnan = deco_ufunc(torch.isnan)
log = deco_ufunc(torch.log)
log10 = deco_ufunc(torch.log10)
log1p = deco_ufunc(torch.log1p)
log2 = deco_ufunc(torch.log2)
logical_not = deco_ufunc(torch.logical_not)
negative = deco_ufunc(torch.negative)
rad2deg = deco_ufunc(torch.rad2deg)
radians = deco_ufunc(torch.deg2rad)
reciprocal = deco_ufunc(torch.reciprocal)
rint = deco_ufunc(torch.round)
sign = deco_ufunc(torch.sign)
signbit = deco_ufunc(torch.signbit)
sin = deco_ufunc(torch.sin)
sinh = deco_ufunc(torch.sinh)
sqrt = deco_ufunc(torch.sqrt)
square = deco_ufunc(torch.square)
tan = deco_ufunc(torch.tan)
tanh = deco_ufunc(torch.tanh)
trunc = deco_ufunc(torch.trunc)

invert = deco_ufunc(torch.bitwise_not)

# special cases: torch does not export these names
def _cbrt(x):
    return torch.pow(x, 1 / 3)


def _positive(x):
    return +x


def _absolute(x):
    # work around torch.absolute not impl for bools
    if x.dtype == torch.bool:
        return x
    return torch.absolute(x)

cbrt = deco_ufunc(_cbrt)
positive = deco_ufunc(_positive)
absolute = deco_ufunc(_absolute)
