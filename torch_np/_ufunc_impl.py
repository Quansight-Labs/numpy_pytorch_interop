import torch

from . import _util
from . import _helpers


def deco_binary_ufunc(torch_func):
    """Common infra for binary ufuncs: receive arrays, sort out type casting,
    broadcasting, out array handling etc, and delegate to the
    pytorch function for actual work, then wrap the results into an array.

    x1, x2 are arrays! array_like -> array conversion is the caller responsibility.
    """

    def wrapped(
        x1,
        x2,
        /,
        out=None,
        *,
        where=True,
        casting="same_kind",
        order="K",
        dtype=None,
        subok=False,
        **kwds,
    ):
        _util.subok_not_ok(subok=subok)
        if order != "K" or not where:
            raise NotImplementedError

        # XXX: dtype=... parameter
        if dtype is not None:
            raise NotImplementedError

        arrays = (x1, x2)
        tensors = _helpers.cast_and_broadcast(arrays, out, casting)

        result = torch_func(*tensors)

        return _helpers.result_or_out(result, out)

    return wrapped


def deco_unary_ufunc(torch_func):
    # TODO: deduplicate with `deco_binary_ufunc` above. Need to figure out the
    #       effect of the `dtype` parameter, does it differ between unary and binary ufuncs.
    def wrapped(
        x1,
        /,
        out=None,
        *,
        where=True,
        casting="same_kind",
        order="K",
        dtype=None,
        subok=False,
        **kwds,
    ):
        _util.subok_not_ok(subok=subok)
        if order != "K" or not where:
            raise NotImplementedError

        # XXX: dtype=... parameter
        if dtype is not None:
            raise NotImplementedError

        arrays = (x1,)
        tensors = _helpers.cast_and_broadcast(arrays, out, casting)

        result = torch_func(*tensors)

        return _helpers.result_or_out(result, out)

    return wrapped


# binary ufuncs: the list is autogenerated, cf autogen/gen_ufunc_2.py
# And edited manually! np.equal  <--> torch.eq, not torch.equal
add = deco_binary_ufunc(torch.add)
arctan2 = deco_binary_ufunc(torch.arctan2)
bitwise_and = deco_binary_ufunc(torch.bitwise_and)
bitwise_or = deco_binary_ufunc(torch.bitwise_or)
bitwise_xor = deco_binary_ufunc(torch.bitwise_xor)
copysign = deco_binary_ufunc(torch.copysign)
divide = deco_binary_ufunc(torch.divide)
equal = deco_binary_ufunc(torch.eq)
float_power = deco_binary_ufunc(torch.float_power)
floor_divide = deco_binary_ufunc(torch.floor_divide)
fmax = deco_binary_ufunc(torch.fmax)
fmin = deco_binary_ufunc(torch.fmin)
fmod = deco_binary_ufunc(torch.fmod)
gcd = deco_binary_ufunc(torch.gcd)
greater = deco_binary_ufunc(torch.greater)
greater_equal = deco_binary_ufunc(torch.greater_equal)
heaviside = deco_binary_ufunc(torch.heaviside)
hypot = deco_binary_ufunc(torch.hypot)
lcm = deco_binary_ufunc(torch.lcm)
ldexp = deco_binary_ufunc(torch.ldexp)
left_shift = deco_binary_ufunc(torch.bitwise_left_shift)
less = deco_binary_ufunc(torch.less)
less_equal = deco_binary_ufunc(torch.less_equal)
logaddexp = deco_binary_ufunc(torch.logaddexp)
logaddexp2 = deco_binary_ufunc(torch.logaddexp2)
logical_and = deco_binary_ufunc(torch.logical_and)
logical_or = deco_binary_ufunc(torch.logical_or)
logical_xor = deco_binary_ufunc(torch.logical_xor)
matmul = deco_binary_ufunc(torch.matmul)
maximum = deco_binary_ufunc(torch.maximum)
minimum = deco_binary_ufunc(torch.minimum)
remainder = deco_binary_ufunc(torch.remainder)
multiply = deco_binary_ufunc(torch.multiply)
nextafter = deco_binary_ufunc(torch.nextafter)
not_equal = deco_binary_ufunc(torch.not_equal)
power = deco_binary_ufunc(torch.pow)
remainder = deco_binary_ufunc(torch.remainder)
right_shift = deco_binary_ufunc(torch.bitwise_right_shift)
subtract = deco_binary_ufunc(torch.subtract)
divide = deco_binary_ufunc(torch.divide)


# unary ufuncs: the list is autogenerated, cf autogen/gen_ufunc_2.py
absolute = deco_unary_ufunc(torch.absolute)
# absolute = deco_unary_ufunc(torch.absolute)
arccos = deco_unary_ufunc(torch.arccos)
arccosh = deco_unary_ufunc(torch.arccosh)
arcsin = deco_unary_ufunc(torch.arcsin)
arcsinh = deco_unary_ufunc(torch.arcsinh)
arctan = deco_unary_ufunc(torch.arctan)
arctanh = deco_unary_ufunc(torch.arctanh)
ceil = deco_unary_ufunc(torch.ceil)
conjugate = deco_unary_ufunc(torch.conj_physical)
# conjugate = deco_unary_ufunc(torch.conj_physical)
cos = deco_unary_ufunc(torch.cos)
cosh = deco_unary_ufunc(torch.cosh)
deg2rad = deco_unary_ufunc(torch.deg2rad)
degrees = deco_unary_ufunc(torch.rad2deg)
exp = deco_unary_ufunc(torch.exp)
exp2 = deco_unary_ufunc(torch.exp2)
expm1 = deco_unary_ufunc(torch.expm1)
fabs = deco_unary_ufunc(torch.absolute)
floor = deco_unary_ufunc(torch.floor)
isfinite = deco_unary_ufunc(torch.isfinite)
isinf = deco_unary_ufunc(torch.isinf)
isnan = deco_unary_ufunc(torch.isnan)
log = deco_unary_ufunc(torch.log)
log10 = deco_unary_ufunc(torch.log10)
log1p = deco_unary_ufunc(torch.log1p)
log2 = deco_unary_ufunc(torch.log2)
logical_not = deco_unary_ufunc(torch.logical_not)
negative = deco_unary_ufunc(torch.negative)
rad2deg = deco_unary_ufunc(torch.rad2deg)
radians = deco_unary_ufunc(torch.deg2rad)
reciprocal = deco_unary_ufunc(torch.reciprocal)
rint = deco_unary_ufunc(torch.round)
sign = deco_unary_ufunc(torch.sign)
signbit = deco_unary_ufunc(torch.signbit)
sin = deco_unary_ufunc(torch.sin)
sinh = deco_unary_ufunc(torch.sinh)
sqrt = deco_unary_ufunc(torch.sqrt)
square = deco_unary_ufunc(torch.square)
tan = deco_unary_ufunc(torch.tan)
tanh = deco_unary_ufunc(torch.tanh)
trunc = deco_unary_ufunc(torch.trunc)

invert = deco_unary_ufunc(torch.bitwise_not)

# special cases: torch does not export these names
def _cbrt(x):
    return torch.pow(x, 1 / 3)


def _positive(x):
    return +x


cbrt = deco_unary_ufunc(_cbrt)
positive = deco_unary_ufunc(_positive)
