from dump_namespace import grab_namespace, get_signature

import numpy as np

namespace = np

dct = grab_namespace(namespace)


# SKIP these (need special handling)
skip = {np.frexp, np.modf,    # non-standard unary ufunc signatures
        np.isnat,
        np.invert,      # bitwise NOT operator
        np.spacing,     # niche, does not have a direct equivalent
}

# np functions where torch names differ
torch_names = {np.radians : "deg2rad",
               np.degrees : "rad2deg",
               np.conjugate : "conj_physical",
               np.fabs : "absolute",       # FIXME: np.fabs raises form complex
               np.rint : "round"
}


# np functions which do not have a torch equivalent
default_stanza = "torch.{torch_name}(torch.as_tensor(x), out=out)"

stanzas = {np.cbrt : "torch.pow(torch.as_tensor(x), 1/3, out=out)",

           # XXX what on earth is np.positive
           np.positive: "+torch.as_tensor(x)",

           # these three do not have an out arg
           np.isinf: "torch.isinf(torch.as_tensor(x))",
           np.isnan: "torch.isnan(torch.as_tensor(x))",
           np.isfinite: "torch.isfinite(torch.as_tensor(x))",
}


# for these np functions, pytorch analog does not have the out= arg
needs_out = {np.isinf, np.isnan, np.isfinite, np.positive}
add_out_stanza = """
    if out is not None:
        out[...] = result
"""


header = """\
# this file is autogenerated via gen_ufuncs.py
# do not edit manually!

import torch

import _util

"""

test_header = header + """\
import numpy as np
import torch

from _unary import *
"""


template = """

def {np_name}(x, /, out=None, *, where=True, casting='same_kind', order='K',
          dtype=None, subok=False, **kwds):
    _util.subok_not_ok(subok=subok)
    if order != 'K' or casting != 'same_kind' or not where:
        raise NotImplementedError
    if out is not None:
      # XXX dtypes, casting
        out = out.to(dtype)
    result = {torch_stanza}
    if dtype is not None:
        result = result.to(dtype)
    {out_stanza}
    return result

"""

test_template = """

def test_{np_name}():
    np.testing.assert_allclose(np.{np_name}(0.5),
                               {np_name}(0.5), atol=1e-14)

"""


###### UNARY UFUNCS ###################################

_all_list = []
main_text = header
test_text = test_header

for ufunc in dct['ufunc']:
    if ufunc in skip:
        continue

    if ufunc.nin == 1:
        # print(get_signature(ufunc))

        torch_name = torch_names.get(ufunc)
        if torch_name is None:
            torch_name = ufunc.__name__

        torch_stanza = stanzas.get(ufunc)
        if torch_stanza is None:
            torch_stanza = default_stanza.format(torch_name=torch_name)

        out_stanza= add_out_stanza if ufunc in needs_out else ""

        main_text += template.format(np_name=ufunc.__name__,
                                     torch_stanza=torch_stanza,
                                     out_stanza=out_stanza)
        test_text += test_template.format(np_name=ufunc.__name__)

        _all_list.append(ufunc.__name__)

main_text += "\n\n__all__ = %s" % _all_list


with open("_unary.py", "w") as f:
    f.write(main_text)

with open("test_unary.py", "w") as f:
    f.write(test_text)


###### BINARY UFUNCS ###################################

_all_list = []
main_text = header
test_text = test_header

for ufunc in dct['ufunc']:
    if ufunc in skip:
        continue

    if ufunc.nin == 2:
        print(get_signature(ufunc))


